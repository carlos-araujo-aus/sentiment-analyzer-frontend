// src/features/analysis/analysisSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import type { PayloadAction } from '@reduxjs/toolkit';
import apiClient from '../../services/apiClient'; // Import our configured API client

// Define the shape of the analysis results (should match the backend response)
interface AnalysisResults {
  sentiment: { label: string; score: number };
  emotions: Record<string, number>;
  keywords: { text: string; relevance: number; count: number }[];
}

// Define the shape of our slice's state
interface AnalysisState {
  results: AnalysisResults | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: AnalysisState = {
  results: null,
  status: 'idle',
  error: null,
};

// 1. THE REAL ASYNC THUNK
// createAsyncThunk handles the standard async request lifecycle.
// It will automatically dispatch actions for pending, fulfilled, and rejected states.
export const fetchAnalysis = createAsyncThunk(
  'analysis/fetchAnalysis', // This string is used as the prefix for the generated action types
  async (textToAnalyze: string, { rejectWithValue }) => {
    try {
      // Use our apiClient to make the POST request to the /analyze endpoint
      const response = await apiClient.post<AnalysisResults>('/analyze', { text: textToAnalyze });
      // The returned value will become the payload of the `fulfilled` action
      return response.data;
    } catch (err: any) {
      // Use `rejectWithValue` to handle errors in a standardized way.
      // It ensures the payload of the `rejected` action is consistent.
      if (err.response && err.response.data && err.response.data.error) {
        // If the backend sent a specific error message, pass it along
        return rejectWithValue(err.response.data.error);
      }
      // Otherwise, return a generic error message
      return rejectWithValue(err.message || 'An unexpected network error occurred');
    }
  }
);

const analysisSlice = createSlice({
  name: 'analysis',
  initialState,
  // `reducers` are for synchronous actions
  reducers: {
    resetAnalysis: (state) => {
      state.results = null;
      state.status = 'idle';
      state.error = null;
    },
  },
  // `extraReducers` are for handling actions defined outside the slice,
  // like the ones generated by createAsyncThunk.
  extraReducers: (builder) => {
    builder
      .addCase(fetchAnalysis.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(fetchAnalysis.fulfilled, (state, action: PayloadAction<AnalysisResults>) => {
        state.status = 'succeeded';
        state.results = action.payload;
      })
      .addCase(fetchAnalysis.rejected, (state, action) => {
        state.status = 'failed';
        // The payload comes from what we passed to `rejectWithValue`
        state.error = action.payload as string;
      });
  },
});

export const { resetAnalysis } = analysisSlice.actions;
export default analysisSlice.reducer;
