// src/features/analysis/analysisSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import type { PayloadAction } from '@reduxjs/toolkit';
import apiClient from '../../services/apiClient'; // Import our configured API client

// Define the shape of the analysis results (should match the backend response)
interface AnalysisResults {
  sentiment: { label: string; score: number };
  emotions: Record<string, number>;
  keywords: { text: string; relevance: number; count: number }[];
}

// Define the shape of our slice's state
interface AnalysisState {
  results: AnalysisResults | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: AnalysisState = {
  results: null,
  status: 'idle',
  error: null,
};

// 1. THE REAL ASYNC THUNK
// createAsyncThunk handles the standard async request lifecycle.
// It will automatically dispatch actions for pending, fulfilled, and rejected states.
export const fetchAnalysis = createAsyncThunk(
  'analysis/fetchAnalysis', // This string is used as the prefix for the generated action types
  // The thunk now expects an object with text and captchaToken
  async (
    { text, captchaToken }: { text: string; captchaToken: string }, // <-- 1. Update the argument signature
    { rejectWithValue }
  ) => {
    try {
      // Pass the entire object as the payload for the POST request
      const response = await apiClient.post<AnalysisResults>('/analyze', {
        text,
        captchaToken, // <-- 2. Send the token to the backend
      });
      return response.data;
    } catch (err: any) {
      if (err.response && err.response.data && err.response.data.error) {
        return rejectWithValue(err.response.data.error);
      }
      return rejectWithValue(
        err.message || 'An unexpected network error occurred'
      );
    }
  }
);

const analysisSlice = createSlice({
  name: 'analysis',
  initialState,
  // `reducers` are for synchronous actions
  reducers: {
    resetAnalysis: (state) => {
      state.results = null;
      state.status = 'idle';
      state.error = null;
    },
  },
  // `extraReducers` are for handling actions defined outside the slice,
  // like the ones generated by createAsyncThunk.
  extraReducers: (builder) => {
    builder
      .addCase(fetchAnalysis.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(
        fetchAnalysis.fulfilled,
        (state, action: PayloadAction<AnalysisResults>) => {
          state.status = 'succeeded';
          state.results = action.payload;
        }
      )
      .addCase(fetchAnalysis.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });
  },
});

export const { resetAnalysis } = analysisSlice.actions;
export default analysisSlice.reducer;
